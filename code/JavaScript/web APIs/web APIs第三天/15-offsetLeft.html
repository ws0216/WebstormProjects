<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    div {
      position: relative;
      width: 200px;
      height: 200px;
      background-color: pink;
      margin: 100px;
    }

    p {
      width: 100px;
      height: 100px;
      background-color: purple;
      margin: 50px;
    }
  </style>
</head>

<body>
  <div>
    <p></p>
  </div>
  <script>
    /*
    4.元素尺寸于位置
    使用场景:
    前面案例滚动多少距离，都是我们自己算的，最好是页面滚动到某个元素，就可以做某些事。
    简单说，就是通过js的方式，得到元素在页面中的位置
    这样我们可以做，页面滚动到这个位置，就可以做某些操作，省去计算了

    4.元素尺寸于位置-尺寸
    获取宽高:
    获取元素的自身宽高、包含元素自身设置的宽高、padding、border
    offsetWidth和offsetHeight
    获取出来的是数值,方便计算
    注意:获取的是可视宽高,如果盒子是隐藏的,获取的结果是0
    获取位置:
    获取元素距离自己带有定位的父级元素的左、上距离
    offsetLeft和offsetTop 注意是只读属性

    offsetLeft和offsetTop: 受父亲的影响,它的父亲有定位则以父亲为准,没有定位则往上去找最近的带有定位的父亲为准

    // 检测盒子的位置  相对于最近一级带有定位的祖先元素

    一般情况下都是标准流,直接获取就行

    获取位置:
    1. offsetLeft和offsetTop 注意是只读属性
    获取元素距离自己定位父级元素的左、上距离

    总结
    1. offsetWidth和offsetHeight是得到元素什么的宽高?
    内容 + padding + border
    2. offsetTop和offsetLeft得到位置以谁为准?
    带有定位的父级
    如果都没有则以文档左上角为准



    */
    const div = document.querySelector('div')
    const p = document.querySelector('p')
    // console.log(div.offsetLeft) // 108 = 100 + 8  因为body里面有一个8px的外边距
    // 检测盒子的位置  最近一级带有定位的祖先元素
    console.log(p.offsetLeft) // 158 = 8 + 100 + 50
  </script>
</body>

</html>
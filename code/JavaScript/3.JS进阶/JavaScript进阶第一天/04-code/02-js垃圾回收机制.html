<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /*
    1.4 JS垃圾回收机制
    目标:了解JS垃圾回收机制的执行过程
    学习目的:为了闭包做铺垫
    学习路径:
    1. 什么是垃圾回收机制
    2. 内存的声明周期
    3. 垃圾回收的算法说明

    1.什么是垃圾回收机制?
    垃圾回收机制(Garbage Collection)简称GC
    JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。
    正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题
    但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏(内存无法被回收)的情况
    不再用到的内存，没有及时释放，就叫做内存泄漏

    2.内存的生命周期
    JS环境中分配的内存，一般有如下生命周期:
    1.内存分配:当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
    2.内存使用:即读写内存，也就是使用变量、函数等
    3.内存回收:使用完毕，由垃圾回收自动回收不再使用的内存
    4.说明:
    全局变量一般不会回收(关闭页面回收):
    一般情况下局部变量的值，不用了，会被自动回收掉

    // 为变量分配内存
    const i = 11
    const str = 'pink老师'
    //为对象分配内存
    const person ={
      age:18,
      uname:'pink老师'
    }
    //为函数分配内存
    function sum(a,b) {
      return a + b
    }

    总结
    1.什么是垃圾回收机制?
    简称 GC
    JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收
    2.什么是内存泄漏?
    不再用到的内存，没有及时释放，就叫做内存泄漏
    3.内存的生命周期是什么样的?
    内存分配、内存使用、内存回收
    全局变量一般不会回收;一般情况下局部变量的值,不用了，会被自动回收掉

    拓展-JS垃圾回收机制-算法说明
    堆栈空间分配区别:
    1.栈(操作系统):由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。
    2.堆(操作系统):一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。
    下面介绍两种常见的浏览器垃圾回收算法:引用计数法和标记清除法

    引用计数
    IE采用的引用计数算法，定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象
    算法:
    1. 跟踪记录被引用的次数
    2. 如果被引用了一次，那么就记录次数1,多次引用会累加 ++
    3. 如果减少一个引用就减1--
    4. 如果引用次数是0，则释放内存

    // 所以程序员在很多情况下 想把某一个对象或者数组给它释放掉的话 可以直接让它等于null就行了
    例如:
    引用计数
    const arr = [1,2,3,4]  // 栈里面开辟一个空间存放数组的地址 堆里面存放数组[1,2,3,4] 地址指向堆
    // arr -> 0x11111 -> [1,2,3,4]
    // 地址指向了数组 说明数组被引用了 记数组的引用次数为1
    arr = null
    // 地址为空 不再指向堆了 那么说明堆里面的数组没有被引用了 所以引用次数从1变为了0

    let person = {
      age:18,
      name:'佩奇'
    }
    // 复杂数据类型在赋值的时候赋的是地址
    let p = person  // 此时改对象被指向了2次 即被引用了2次
    person = 1
    p = null

    由上面可以看出，引用计数算法是个简单有效的算法。

    引用计数
    但它却存在一个致命的问题:嵌套引用(循环引用)
    如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。
    function fn() {
      let o1 = {}
      let o2 = {}
      // o1需要用到o2 o1指向o2一次
      o1.a = o2
      // o2需要用到o1 o2指向o1一次
      o2.a = o1
    return '引用计数无法回收'
    }
    fn()
    因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露

    下面介绍两种常见的浏览器垃圾回收算法:引用计数法和标记清除法
    标记清除法
    现代的浏览器已经不再使用引用计数算法了。
    现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。
    核心:
    1.标记清除算法将“不再使用的对象”定义为“无法达到的对象”。
    2.就是从根部(在JS中就是全局对象)出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。
    3.那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。

    标记清除法
    标记所有的引用

    标记清除
    function fn( ) {
    let o1 = {}
    let o2 ={}
    01.a = o2
    o2.a = o1
    return'引用计数无法回收’
    fn()
    根部已经访问不到，所以自动清除

    总结
    1. 标记清除法核心思路是什么?
    从根部扫描对象，能查找到的就是使用的，查找不到的就要回收





    */

    for (let i = 1; i <= 3; i++) {

    }
    let num = 10
    function fn() {
      const str = 'andy'
      // str = 'lily'
      console.log(str)
    }
    fn()
    fn()
    fn()
  </script>
</body>

</html>
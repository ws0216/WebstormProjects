<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /*
    2.构造函数
    封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。
    同样的将变量和函数组合到了一起并能通过 this 实现数据的共享，所不同的是借助构造函数创建出来的实例对象之间是彼此不影响的

    总结:
    1.构造函数体现了面向对象的封装特性
    2.构造函数实例创建的对象彼此独立、互不影响

    封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装
    前面我们学过的构造函数方法很好用，但是 存在浪费内存的问题

    面向对象编程的特性:比如封装性、继承性等，可以借助于构造函数来实现
    前面我们学过的构造函数方法很好用，但是存在浪费内存的问题

    总结
    1.Js 实现面向对象需要借助于谁来实现?
    > 构造函数
    2.构造函数存在什么问题?
    >浪费内存

    3.1 原型
    目标:能够利用原型对象实现方法共享
    构造函数通过原型分配的函数是所有对象所 共享的。
    JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象
    这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存
    我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法
    构造函数和原型对象中的this 都指向 实例化的对象

    prototype:原型 雏形 蓝本
    构造函数是Java的类概念，原型是Java的static。
    因为js是面向函数编程的，每个函数都会占用内存，所以选择了prototype这种折中方式
    过来人告诉你，别说这是什么java的静态方法

    总结
    1.原型是什么 ?
        一个对象，我们也称为 prototype 为原型对象
    2.原型的作用是什么?
    共享方法
        可以把那些不变的方法，直接定义在 prototype 对象上
    3.构造函数和原型里面的this指向谁 ?
        实例化的对象

    3.1 原型- this指向
    目标:能够说出构造函数和原型对象中的this 指向
    构造函数和原型对象中的this 都指向 实例化的对象
    原型对象中的this:指向实例化的对象
    原型对象中的constructor属性:指向原型对象的构造函数

    */
    let that
    function Star(uname) {
      // that = this
      // console.log(this)
      this.uname = uname
    }

    console.log(Star.prototype);

    // 原型对象里面的函数this指向的还是 实例对象 ldh
    Star.prototype.sing = function () {
      that = this
      console.log('唱歌')
    }
    // 实例对象 ldh   
    // 构造函数里面的 this 就是  实例对象  ldh
    const ldh = new Star('刘德华')
    ldh.sing()
    console.log(that === ldh)
  </script>
</body>

</html>